names(vlayer_L2)<-"lidar_vlayer_L2"
r_list$vlayer_L2<-vlayer_L2
} #End of empty check
} #End of metric name check
if("lidar_vlayer_L3" %in% metric_names){
if(nrow(L3@data)!=0){
vlayer_L3<-lidR::voxel_metrics(L3,
eval(vox_expr),
res = vox_res)
vlayer_L3<-lidR::LAS(vlayer_L3)
vlayer_L3<-lidR::pixel_metrics(vlayer_L3,
~list(vlayer_L3=sum(vol)),
res = res)
vlayer_L3<-terra::resample(vlayer_L3,empty_raster)
names(vlayer_L3)<-"lidar_vlayer_L3"
r_list$vlayer_L3<-vlayer_L3
} else {
vlayer_L3<-empty_raster
names(vlayer_L3)<-"lidar_vlayer_L3"
r_list$vlayer_L3<-vlayer_L3
} #End of empty check
} #End of metric name check
devtools::document
devtools::document()
install.packages("devtools")
library(devtools)
devtools::document()
devtools::document()
install.packages("moments")
library(moments)
devtools::document()
devtools::document()
las<-lidR::readLAS("F:/Cairngorms_project/LiDAR/Temp/280000_805000.laz")
ground_classified = F
res=5
h_cutoff=1.3
gap_thres = 2
mcc_s=1.5
mcc_t=0.3
zmax = 35
shannon_cut=c(-1,2,5,10,15,35)
vox_res=0.5
L1_range=c(0,1)
L2_range=c(1,10)
L3_range=c(10,35)
metrics = "all"
metric_names<-c("lidar_maxH","lidar_meanH","lidar_stdH","lidar_skewH","lidar_kurH","lidar_p_05","lidar_p_10","lidar_p_25","lidar_p_50","lidar_p_75","lidar_p_90","lidar_p_95","lidar_p_999",
paste0("lidar_vci_",c(2,5,10,15,20),"m"),
"lidar_Cov","lidar_gapFrac","lidar_grndFrac",
"lidar_height_cv","lidar_rcv","lidar_rms","lidar_canopy_shannon",
"lidar_Tvolume","lidar_ePAI",
"lidar_vlayer_L1","lidar_vlayer_L2","lidar_vlayer_L3",
"lidar_meanH_L1","lidar_sdH_L1","lidar_meanH_L2","lidar_sdH_L2","lidar_meanH_L3","lidar_sdH_L3",
paste0("lidar_vci_L",c(1,2,3)))
additional_metrics<-c()
if(metrics == "all"){
metric_names<-metric_names
} else {
metric_names<-metrics
}
r_list<-list() #Create a list to store results
if(ground_classified==F){
las<-lidR::classify_ground(las,lidR::mcc(s=mcc_s,t=mcc_t))
}
las<-lidR::normalize_height(las,lidR::knnidw())
las_filtered<-lidR::filter_poi(las,Z>h_cutoff)
empty_raster<-lidR::pixel_metrics(las,~list(zmax = mean(Z,na.rm = T)),res = res)
terra::values(empty_raster)<-0
if(nrow(las_filtered@data)==0){
std_names<-c("lidar_maxH","lidar_meanH","lidar_stdH","lidar_skewH","lidar_kurH","lidar_p_05","lidar_p_10","lidar_p_25","lidar_p_50","lidar_p_75","lidar_p_90","lidar_p_95")
if(sum(std_names %in% metric_names)>=1){
std_metrics<-terra::rast(replicate(12,empty_raster))
names(std_metrics)<-std_names
wanted<-std_names[which(std_names) %in% metric_names]
std_metrics<-std_metrics[[wanted]]
r_list$std_metrics<-std_metrics
}
if("lidar_p_999" %in% metrics){
q999<-empty_raster
names(q999)<-"lidar_p_999"
r_list$q999<-q999
}
if(sum(paste0("lidar_vci_",c(2,5,10,15,20),"m") %in% metric_names) >=1){
lidar_VCI_combined<-terra::rast(replicate(5,empty_raster))
names(lidar_VCI_combined)<-paste0("lidar_vci_",c(2,5,10,15,20),"m")
wanted<-paste0("lidar_vci_",c(2,5,10,15,20),"m")[which(paste0("lidar_vci_",c(2,5,10,15,20),"m") %in% metric_names)]
lidar_VCI_combined<-lidar_VCI_combined[[wanted]]
r_list$lidar_VCI_combined<-lidar_VCI_combined
}
} else {
# 4. Standard metrics ####
#Point cloud not empty, calculation needed
std_names<-c("lidar_maxH","lidar_meanH","lidar_stdH","lidar_skewH","lidar_kurH","lidar_p_05","lidar_p_10","lidar_p_25","lidar_p_50","lidar_p_75","lidar_p_90","lidar_p_95")
if(sum(std_names %in% metric_names)>=1){
#Calculate metrics
std_metrics<-lidR::pixel_metrics(las_filtered,lidR::.stdmetrics_z,res = res)
std_metrics<-std_metrics[[c("zmax","zmean","zsd","zskew","zkurt","zq5","zq10","zq25","zq50","zq75","zq90","zq95")]]
names(std_metrics)<-std_names
#Select the relevant metrics
wanted<-std_names[which(std_names %in% metric_names)]
std_metrics<-std_metrics[[wanted]]
std_metrics<-terra::resample(std_metrics,empty_raster)
r_list$std_metrics<-std_metrics
}
#5. 99.9th quantile ####
#Also add the 999th quantile
if("lidar_p_999" %in% metric_names){
q999<-lidR::pixel_metrics(las_filtered,
res = res,
func = ~q99_f(z = Z))
q999<-terra::resample(q999,empty_raster)
names(q999)<-"lidar_p_999"
r_list$q999<-q999
}
#6. VCI ####
las_filtered_vci<-las_filtered
colnames(las_filtered_vci@data)[colnames(las@data)=="Z"]<-"z" #VCI() takes z not Z
if("lidar_vci_2m" %in% metric_names){
vci2exp<-substitute(~lidR::VCI(z,zmax,by),list(zmax = zmax, by = 2))
vci2<-lidR::pixel_metrics(las_filtered_vci,eval(vci2exp),res = res)
vci2<-terra::resample(vci2,empty_raster)
names(vci2)<-"lidar_vci_2m"
r_list$lidar_VCI_2<-vci2
}
if("lidar_vci_5m" %in% metric_names){
vci5exp<-substitute(~lidR::VCI(z,zmax,by),list(zmax = zmax, by = 5))
vci5<-lidR::pixel_metrics(las_filtered_vci,eval(vci5exp),res = res)
vci5<-terra::resample(vci5,empty_raster)
names(vci5)<-"lidar_vci_5m"
r_list$lidar_VCI_5<-vci5
}
if("lidar_vci_10m" %in% metric_names){
vci10exp<-substitute(~lidR::VCI(z,zmax,by),list(zmax = zmax, by = 10))
vci10<-lidR::pixel_metrics(las_filtered_vci,eval(vci10exp),res = res)
vci10<-terra::resample(vci10,empty_raster)
names(vci10)<-"lidar_vci_10m"
r_list$lidar_VCI_10<-vci10
}
if("lidar_vci_15m" %in% metric_names){
vci15exp<-substitute(~lidR::VCI(z,zmax,by),list(zmax = zmax, by = 15))
vci15<-lidR::pixel_metrics(las_filtered_vci,eval(vci15exp),res = res)
vci15<-terra::resample(vci15,empty_raster)
names(vci15)<-"lidar_vci_15m"
r_list$lidar_VCI_15<-vci15
}
if("lidar_vci_20m" %in% metric_names){
vci20exp<-substitute(~lidR::VCI(z,zmax,by),list(zmax = zmax, by = 20))
vci20<-lidR::pixel_metrics(las_filtered_vci,eval(vci20exp),res = res)
vci20<-terra::resample(vci20,empty_raster)
names(vci20)<-"lidar_vci_20m"
r_list$lidar_VCI_20<-vci20
}
} # End of check empty else{}
las_first<-lidR::filter_first(las)
if("lidar_Cov" %in% metric_names){
cov_exp<-substitute(~cov_f(Z,h_cutoff),list(h_cutoff = h_cutoff))
cov<-lidR::pixel_metrics(
las_first,
res = res,
func = eval(cov_exp)
)
names(cov)<-"lidar_Cov"
cov<-terra::resample(cov,empty_raster)
r_list$lidar_Cov<-cov
}
if("lidar_gapFrac" %in% metric_names){
gapFrac_exp<-substitute(~gapFrac_f(Z,gap_thres),list(gap_thres = gap_thres))
gapFrac<-lidR::pixel_metrics(
las_first,
res = res,
func = eval(gapFrac_exp)
)
gapFrac<-terra::resample(gapFrac,empty_raster)
names(gapFrac)<-"lidar_gapFrac"
r_list$lidar_gapFrac<-gapFrac
}
if("lidar_grndFrac" %in% metric_names){
grndFrac<-lidR::pixel_metrics(
las_first,
~list(grndFrac=length(which(Z<0.5))/length(is.na(Z)==F)),
res = res
)
grndFrac<-terra::resample(grndFrac,empty_raster)
names(grndFrac)<-"lidar_grndFrac"
r_list$lidar_grndFrac<-grndFrac
}
terra::plot(r_list$lidar_gapFrac)
rough_names<-c("lidar_height_cv","lidar_rcv","lidar_rms","lidar_canopy_shannon")
sum(rough_names %in% metric_names) >= 1
rough_exp<-substitute(~roughness_metrics_f(Z,shannon_cut),list(shannon_cut = shannon_cut))
rough<-lidR::pixel_metrics(
las,
func = eval(rough_exp),
res = res)
rough<-terra::resample(rough,empty_raster)
names(rough)<-rough_names
rough<-rough[[rough_names[which(rough_names %in% metric_names)]]]
r_list$rough<-rough
terra::plot(r_list$rough$lidar_rcv)
r_list$rough$lidar_rcv
summary(r_list$rough$lidar_rcv)
?IQR
?median
traceback()
gc()
library(lidR)
?mcc
?mcc
?do.call
?do.call
?lidR::mcc
lidar_SHM<-function(las,
DTM_fp,
DTM_res = 2.3,
max_shrub_ht = 1.025,
stretch_factor = 22,
mcc_s = 0.5,
mcc_t = 0.525,
shm_res = 0.2){
require(raster)
if(is(las,"LAS")){
#Normalise height based on a coarse DTM that essentially gives average height of shrubs+ground
DTM<-raster::raster(DTM_fp)
las<-lidR::normalize_height(las,
tin(),
dtm = DTM,
add_lasattribute = T)
#Remove trees based on a threshold called "max_shrub_ht"
las<-lidR::filter_poi(las,Z<max_shrub_ht)
las<-lidR::filter_poi(las,Z>(-1)) #Added to remove artifacts
#Add an attribute that indicates how much we want to stretch
las<-lidR::add_lasattribute(las,
x = las$Z*(stretch_factor-1),
name = "Z_stretch",
desc = "stretch_coefficient")
#Remove the original normalisation
las<-lidR::unnormalize_height(las)
#Stretch Z to get a pseudoforest
las$Z<-las$Z+las$Z_stretch
#Use MCC to identify ground points in the pseudoforest
las<-lidR::classify_ground(las,mcc(s = mcc_s,t = mcc_t))
#Normalise based on the MCC ground classification
new_dtm<-lidR::rasterize_terrain(las,
res = DTM_res,
algorithm = tin())
las<-lidR::normalize_height(las,tin(),dtm = new_dtm)
chm<-lidR::rasterize_canopy(las,
res = shm_res,
algorithm = p2r(subcircle = 0.1))
chm<-chm/stretch_factor
return(chm)
} # End of is(las,"LAS")
if(is(las,"LAScatalog")){
options<-list(
need_output_file=T,
need_buffer = T
)
res<-catalog_map(las,
lidar_SHM,
DTM_fp = DTM_fp,
DTM_res = DTM_res,
max_shrub_ht=max_shrub_ht,
stretch_norm_pts=stretch_norm_pts,
stretch_factor=stretch_factor,
mcc_s=mcc_s,
mcc_t=mcc_t,
shm_res=shm_res,
.options = options)
} #End of is(las,"LAScatalog")
}
t1<-readLAS("F:/Cairngorms_project/LiDAR/Veg_survey_roi/301021_810991_5.las")
t1<-lidR::readLAS("F:/Cairngorms_project/LiDAR/Veg_survey_roi/301021_810991_5.las")
t2<-lidar_SHM(las = t1,DTM_fp = "F:/Cairngorms_project/LiDAR/2023_DTM_CHM_DSM_final/2023_DTM_2m.tif")
?lidR::tin
lidar_SHM<-function(las,
DTM_fp,
DTM_res = 2.3,
max_shrub_ht = 1.025,
stretch_factor = 22,
mcc_s = 0.5,
mcc_t = 0.525,
shm_res = 0.2){
require(raster)
if(is(las,"LAS")){
#Normalise height based on a coarse DTM that essentially gives average height of shrubs+ground
DTM<-raster::raster(DTM_fp)
las<-lidR::normalize_height(las,
lidR::tin(),
dtm = DTM,
add_lasattribute = T)
#Remove trees based on a threshold called "max_shrub_ht"
las<-lidR::filter_poi(las,Z<max_shrub_ht)
las<-lidR::filter_poi(las,Z>(-1)) #Added to remove artifacts
#Add an attribute that indicates how much we want to stretch
las<-lidR::add_lasattribute(las,
x = las$Z*(stretch_factor-1),
name = "Z_stretch",
desc = "stretch_coefficient")
#Remove the original normalisation
las<-lidR::unnormalize_height(las)
#Stretch Z to get a pseudoforest
las$Z<-las$Z+las$Z_stretch
#Use MCC to identify ground points in the pseudoforest
las<-lidR::classify_ground(las,lidR::mcc(s = mcc_s,t = mcc_t))
#Normalise based on the MCC ground classification
new_dtm<-lidR::rasterize_terrain(las,
res = DTM_res,
algorithm = lidR::tin())
las<-lidR::normalize_height(las,lidR::tin(),dtm = new_dtm)
chm<-lidR::rasterize_canopy(las,
res = shm_res,
algorithm = lidR::p2r(subcircle = 0.1))
chm<-chm/stretch_factor
return(chm)
} # End of is(las,"LAS")
if(is(las,"LAScatalog")){
options<-list(
need_output_file=T,
need_buffer = T
)
res<-lidR::catalog_map(las,
lidar_SHM,
DTM_fp = DTM_fp,
DTM_res = DTM_res,
max_shrub_ht=max_shrub_ht,
stretch_norm_pts=stretch_norm_pts,
stretch_factor=stretch_factor,
mcc_s=mcc_s,
mcc_t=mcc_t,
shm_res=shm_res,
.options = options)
} #End of is(las,"LAScatalog")
}
t2<-lidar_SHM(las = t1,DTM_fp = "F:/Cairngorms_project/LiDAR/2023_DTM_CHM_DSM_final/2023_DTM_2m.tif")
DTM_res = 2.3
max_shrub_ht = 1.025
stretch_factor = 22
mcc_s = 0.5
mcc_t = 0.525
shm_res = 0.2
las<-t1
DTM_fp<-"F:/Cairngorms_project/LiDAR/2023_DTM_CHM_DSM_final/2023_DTM_2m.tif"
is(las,"LAS")
DTM<-raster::raster(DTM_fp)
las<-lidR::normalize_height(las,
lidR::tin(),
dtm = DTM,
add_lasattribute = T)
las<-lidR::filter_poi(las,Z<max_shrub_ht)
las<-lidR::filter_poi(las,Z>(-1)) #Added to remove artifacts
las<-lidR::add_lasattribute(las,
x = las$Z*(stretch_factor-1),
name = "Z_stretch",
desc = "stretch_coefficient")
t1
t3<-t1@data
View(t3)
las<-lidR::unnormalize_height(las)
las$Z<-las$Z+las$Z_stretch
las<-lidR::classify_ground(las,lidR::mcc(s = mcc_s,t = mcc_t))
?mcc
warnings()
View(las)
las<-t1
DTM<-raster::raster(DTM_fp)
las<-lidR::normalize_height(las,
lidR::tin(),
dtm = DTM,
add_lasattribute = T)
las<-lidR::filter_poi(las,Z<max_shrub_ht)
las<-lidR::filter_poi(las,Z>(-1)) #Added to remove artifacts
View(las)
las<-t1
DTM<-raster::raster(DTM_fp)
las<-lidR::normalize_height(las,
lidR::tin(),
dtm = DTM,
add_lasattribute = T)
View(las)
t1<-readLAS("F:/Cairngorms_project/LiDAR/plot_33_285470.6_798227.7.las")
t1<-lidR::readLAS("F:/Cairngorms_project/LiDAR/plot_33_285470.6_798227.7.las")
t2<-lidar_SHM(las = t1,DTM_fp = "F:/Cairngorms_project/LiDAR/2023_DTM_CHM_DSM_final/2023_DTM_2m.tif")
plot(t2)
t1<-lidR::readLAScatalog("F:/Cairngorms_project/LiDAR/Temp")
opt_output_files(t1)<-"F:/Cairngorms_project/LiDAR/Temp_output"
lidR::opt_output_files(t1)<-"F:/Cairngorms_project/LiDAR/Temp_output"
lidar_SHM(las = t1,DTM_fp = "F:/Cairngorms_project/LiDAR/2023_DTM_CHM_DSM_final/2023_DTM_2m.tif")
lidar_SHM<-function(las,
DTM_fp,
DTM_res = 2.3,
max_shrub_ht = 1.025,
stretch_factor = 22,
mcc_s = 0.5,
mcc_t = 0.525,
shm_res = 0.2){
require(raster)
if(is(las,"LAS")){
#Normalise height based on a coarse DTM that essentially gives average height of shrubs+ground
DTM<-raster::raster(DTM_fp)
las<-lidR::normalize_height(las,
lidR::tin(),
dtm = DTM,
add_lasattribute = T)
#Remove trees based on a threshold called "max_shrub_ht"
las<-lidR::filter_poi(las,Z<max_shrub_ht)
las<-lidR::filter_poi(las,Z>(-1)) #Added to remove artifacts
#Add an attribute that indicates how much we want to stretch
las<-lidR::add_lasattribute(las,
x = las$Z*(stretch_factor-1),
name = "Z_stretch",
desc = "stretch_coefficient")
#Remove the original normalisation
las<-lidR::unnormalize_height(las)
#Stretch Z to get a pseudoforest
las$Z<-las$Z+las$Z_stretch
#Use MCC to identify ground points in the pseudoforest
las<-lidR::classify_ground(las,lidR::mcc(s = mcc_s,t = mcc_t))
#Normalise based on the MCC ground classification
new_dtm<-lidR::rasterize_terrain(las,
res = DTM_res,
algorithm = lidR::tin())
las<-lidR::normalize_height(las,lidR::tin(),dtm = new_dtm)
chm<-lidR::rasterize_canopy(las,
res = shm_res,
algorithm = lidR::p2r(subcircle = 0.1))
chm<-chm/stretch_factor
return(chm)
} # End of is(las,"LAS")
if(is(las,"LAScatalog")){
options<-list(
need_output_file=T,
need_buffer = T
)
res<-lidR::catalog_map(las,
lidar_SHM,
DTM_fp = DTM_fp,
DTM_res = DTM_res,
max_shrub_ht=max_shrub_ht,
stretch_factor=stretch_factor,
mcc_s=mcc_s,
mcc_t=mcc_t,
shm_res=shm_res,
.options = options)
} #End of is(las,"LAScatalog")
}
lidar_SHM(las = t1,DTM_fp = "F:/Cairngorms_project/LiDAR/2023_DTM_CHM_DSM_final/2023_DTM_2m.tif")
lidar_SHM<-function(las,
DTM_fp,
DTM_res = 2.3,
max_shrub_ht = 1.025,
stretch_factor = 22,
mcc_s = 0.5,
mcc_t = 0.525,
shm_res = 0.2){
require(raster)
if(is(las,"LAS")){
#Normalise height based on a coarse DTM that essentially gives average height of shrubs+ground
DTM<-raster::raster(DTM_fp)
las<-lidR::normalize_height(las,
lidR::tin(),
dtm = DTM,
add_lasattribute = T)
#Remove trees based on a threshold called "max_shrub_ht"
las<-lidR::filter_poi(las,Z<max_shrub_ht)
las<-lidR::filter_poi(las,Z>(-1)) #Added to remove artifacts
#Add an attribute that indicates how much we want to stretch
las<-lidR::add_lasattribute(las,
x = las$Z*(stretch_factor-1),
name = "Z_stretch",
desc = "stretch_coefficient")
#Remove the original normalisation
las<-lidR::unnormalize_height(las)
#Stretch Z to get a pseudoforest
las$Z<-las$Z+las$Z_stretch
#Use MCC to identify ground points in the pseudoforest
las<-lidR::classify_ground(las,lidR::mcc(s = mcc_s,t = mcc_t))
#Normalise based on the MCC ground classification
new_dtm<-lidR::rasterize_terrain(las,
res = DTM_res,
algorithm = lidR::tin())
las<-lidR::normalize_height(las,lidR::tin(),dtm = new_dtm)
chm<-lidR::rasterize_canopy(las,
res = shm_res,
algorithm = lidR::p2r(subcircle = 0.1))
chm<-chm/stretch_factor
return(chm)
} # End of is(las,"LAS")
if(is(las,"LAScatalog")){
options<-list(
need_output_file=T,
need_buffer = T
)
res<-lidR::catalog_map(las,
lidar_SHM,
DTM_fp = DTM_fp,
DTM_res = DTM_res,
max_shrub_ht=max_shrub_ht,
stretch_factor=stretch_factor,
mcc_s=mcc_s,
mcc_t=mcc_t,
shm_res=shm_res,
.options = options)
} #End of is(las,"LAScatalog")
}
lidar_SHM(las = t1,DTM_fp = "F:/Cairngorms_project/LiDAR/2023_DTM_CHM_DSM_final/2023_DTM_2m.tif")
opt_output_files(t1)<-"F:/Cairngorms_project/LiDAR/Temp_output/{ORIGINALFILENAME}"
lidR::opt_output_files(t1)<-"F:/Cairngorms_project/LiDAR/Temp_output/{ORIGINALFILENAME}"
lidar_SHM(las = t1,DTM_fp = "F:/Cairngorms_project/LiDAR/2023_DTM_CHM_DSM_final/2023_DTM_2m.tif")
gc()
devtools::document()
devtools::document()
devtools::check()
